# 算法解释：
   在对问题求解时，总是做出当前看来最好的选择，也就是保证每次考虑局部最优解，通过局部最优解得到全局最优解。
   贪心算法必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。

## 分析基本要素：
    1、具有贪心选择性质。就是说整体的最优解可以通过一系列局部最优的选择，即贪心选择来达到。这是贪心算法可行性的基本要素
    2、最优子结构性质。问题的最优解包含子问题的局部最优解
	3、**具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关**。
    总的来说就是，所有的局部最优解能得到全局最优解，全局最优解能分解为多个局部最优解的集合

## 基本思路：
    从问题的某一个初始解逐步逼近给定目标，以尽可能快的求得更好的解。当达到算法中的某一步不能再继续前进时，算法停止。
    1、问题的某一个初始解出发；
    2、循环得到某个问题的有限个最优解，将所有最优解"相加"得到问题的全局最优解；

## 缺陷/存在的问题：
    1、不能保证求得的最后解是最佳的；
    2、不能用来求最大或最小解问题；
    3、只能求满足某些约束条件的可行解的范围；

# Leetcode案例
===========  455. Assign Cookies (Easy)=============
```bash
题目：
假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。
对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；
并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

示例 1:
输入: g = [1,2,3], s = [1,1]
输出: 1
解释:
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
所以你应该输出1。

示例 2:
输入: g = [1,2], s = [1,2,3]
输出: 2
解释:
你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
你拥有的饼干数量和尺寸都足以让所有孩子满足。
所以你应该输出2
```

**方法一**：暴力求解(无需排序)	//时间复杂度：O(n^2)

```cpp
int findContentChildren_1(vector<int>& g, vector<int>& s)
{
	int count = 0;
	int j = 0;
	for (int i = 0; i < g.size();)
	{
		for (j = i; j < s.size();)
		{
			if (s[j] >= g[i])
			{
				++count;
				++i;
				break;
			}
			++j;
		}
		if (j == s.size())
			++i;
	}
	return count;
}
```

**方法二**：贪心算法（需要排序）		//时间复杂度：O(n)

```cpp
int findContentChildren_2(vector<int>& g, vector<int>& s)
{
	//贪心的思想是，用尽量小的饼干去满足小需求的孩子，所以需要先进行排序
	sort(g.begin(), g.end());
	sort(s.begin(), s.end());

	int i = 0;
	int j = 0;
	//此处已经是有序的，所以循环一次就好
	while (i < g.size() && j < s.size())
	{
		if (s[j] >= g[i])  //满足孩子的需求，则数量+1
			++i;
		++j;		//饼干只能使用一次
	}
	return i;
}
```









